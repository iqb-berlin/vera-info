<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>standards</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="_standards_files/libs/clipboard/clipboard.min.js"></script>
<script src="_standards_files/libs/quarto-html/quarto.js"></script>
<script src="_standards_files/libs/quarto-html/popper.min.js"></script>
<script src="_standards_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="_standards_files/libs/quarto-html/anchor.min.js"></script>
<link href="_standards_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="_standards_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="_standards_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="_standards_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="_standards_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="_standards_files/libs/quarto-diagram/mermaid.min.js"></script>
<script src="_standards_files/libs/quarto-diagram/mermaid-init.js"></script>
<link href="_standards_files/libs/quarto-diagram/mermaid.css" rel="stylesheet">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="gemeinsamer-europäischer-referenzrahmens-ger" class="level1">
<h1>Gemeinsamer Europäischer Referenzrahmens (GER)</h1>
<p>Die Bildungsstandards sind an die im Gemeinsamen Europäischen Referenzrahmen für Fremdsprachen beschriebenen Niveaus angebunden:</p>
<div id="fig-bista" class="border quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-bista-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
    subgraph Abitur
        C(&lt;b&gt;C&lt;/b&gt;&lt;br/&gt;Kompetente&lt;br/&gt;Sprachverwendung)
        C1(C1&lt;br/&gt;&lt;i&gt;Effektive&lt;br/&gt;Operational&lt;br/&gt;Proficiency&lt;/i&gt;)
        C2(C2&lt;br/&gt;&lt;i&gt;Mastery&lt;/i&gt;)
    end
    style Abitur fill:white
    subgraph MSA
        B(&lt;b&gt;B&lt;/b&gt;&lt;br/&gt;Selbstständige&lt;br/&gt;Sprachverwendung)
        B1(B1&lt;br/&gt;&lt;i&gt;Threshold&lt;/i&gt;)
        B2(B2&lt;br/&gt;&lt;i&gt;Vantage&lt;/i&gt;)
    end
    style MSA fill:white
    subgraph HSA
        A(&lt;b&gt;A&lt;/b&gt;&lt;br/&gt;Elementare&lt;br/&gt;Sprachverwendung)
        A1(A1&lt;br/&gt;&lt;i&gt;Breakthrough&lt;/i&gt;)
        A2(A2&lt;br/&gt;&lt;i&gt;Waystage&lt;/i&gt;)
    end
    style HSA fill:white
    A --&gt; A1
    A --&gt; A2
    B --&gt; B1
    B --&gt; B2
    C --&gt; C1
    C --&gt; C2

</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-bista-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Niveaustufen nach dem Gemeinsamen Europäischen Referenzrahmen für Sprachen
</figcaption>
</figure>
</div>
<p>In den Plöner Beschlüssen von 2006 hat die Kultusministerkonferenz festgelegt, dass VERA-8 an die Bildungsstandards für die Sekundarstufe I angekoppelt werden soll. Bei den Bildungsstandards handelt es sich um eine Festlegung von Regelstandards. Diese liegen hinsichtlich ihres Anforderungsniveaus zwischen Mindest- und Optimalstandards. Die folgenden Begriffe werden im Kompetenzstufenmodell von 2009 definiert.</p>
<ul>
<li><strong>Mindeststandards</strong>: Minimum an Kompetenzen, das von allen bis zu einem bestimmten Bildungsabschnitt erreicht werden soll</li>
<li><strong>Regelstandards</strong>: Kompetenzen, die im Durchschnitt bis zu einem bestimmten Bildungsabschnitt erreicht werden sollen</li>
<li><strong>Regelstandard plus</strong>: Kompetenzen, die über die Regelstandards hinausgehen</li>
<li><strong>Optimalstandards</strong>: Leistungserwartungen, die unter sehr guten individuellen Lernvoraussetzungen und der Bereitstellung gelingender Lerngelegenheiten innerhalb und außerhalb der Schule erreicht werden und bei weitem die Erwartungen der Bildungsstandards übertreffen</li>
</ul>
<p>Im Folgenden werden die Leistungen auf den Niveaus A1 bis C1 beschrieben. Schülerinnen und Schüler der 1. Fremdsprache verweilen mehrere Lernjahre auf den Niveaus A2 und B1. In der Regel wird deutlich mehr Lernzeit zum Erreichen des höheren Niveaus benötigt. Da mit VERA-8 Schülerinnen und Schüler des 8. Jahrgangs getestet werden, umfassen die eingesetzten Testaufgaben im Wesentlichen Aufgaben auf den Niveaus A2 und B1. Für die Niveaus A1 und B2 werden deutlich weniger Aufgaben eingesetzt, für das Niveau C1 nur einzelne Teilaufgaben. Auf dieser Grundlage können dann für einzelne Lerngruppen entsprechende Fördermaßnahmen abgeleitet und Konzepte für eine angemessene Weiterarbeit entwickelt werden. Da die Lernprozesse individuell sehr unterschiedlich verlaufen, ist eine differenzierte Schwerpunktsetzung im Unterricht nötig.</p>
<section id="kompetenzmodell" class="level2">
<h2 class="anchored" data-anchor-id="kompetenzmodell">Kompetenzmodell</h2>
<p>Was versteht man unter dem Begriff Kompetenz?</p>
<p>Weinert (2001: 27) beschreibt Kompetenz als</p>
<blockquote class="blockquote">
<p>“die bei Individuen verfügbaren oder von ihnen erlernbaren kognitiven Fähigkeiten und Fertigkeiten, bestimmte Probleme zu lösen, sowie die damit verbundenen motivationalen, volitionalen und sozialen Bereitschaften und Fähigkeiten, die Problemlösungen in variablen Situationen erfolgreich und verantwortungsvoll nutzen zu können.”</p>
</blockquote>
<p>Die Modellierung fremdsprachiger Handlungskompetenz in den Bildungsstandards greift diesen weiten Kompetenzbegriff auf. Sie umfasst nicht nur funktionale kommunikative Kompetenzen wie kommunikative Fertigkeiten und die Verfügung über die sprachlichen Mittel, sondern auch interkulturelle und methodische Kompetenzen sowie Selbst- und Sozialkompetenz.</p>
<section id="in-den-bildungsstandards-ausgewiesene-kompetenzbereiche" class="level3">
<h3 class="anchored" data-anchor-id="in-den-bildungsstandards-ausgewiesene-kompetenzbereiche">In den Bildungsstandards ausgewiesene Kompetenzbereiche</h3>
<div id="fig-standards" class="border quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-standards-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<table class="table-block table" data-quarto-postprocess="true">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<tbody>
<tr class="odd">
<td colspan="2" class="table-block-header1">Funktionale Kommunikative Kompetenzen</td>
</tr>
<tr class="even">
<td class="table-block-header2">Kommunikative Fertigkeiten</td>
<td class="table-block-header2">Verfügung über die sprachlichen Mittel</td>
</tr>
<tr class="odd">
<td class="table-block-content"><p>Leseverstehen<br>
Hör- und Hör-/Sehverstehen<br>
Sprechen</p>
<ul>
<li>An Gesprächen teilnehmen</li>
<li>Zusammenhängendes Sprechen</li>
</ul>
Schreiben<br>
Sprachmittlung
<p></p></td>
<td class="table-block-content"><p>Wortschatz<br>
Grammatik<br>
Aussprache und Intonation<br>
Orthographie</p></td>
</tr>
<tr class="even">
<td colspan="2" class="table-block-header1">Interkulturelle Kompetenzen</td>
</tr>
<tr class="odd">
<td colspan="2" class="table-block-content"><p>Soziokulturelles Orientierungswissen<br>
Verständnisvoller Umgang mit kultureller Differenz<br>
Praktische Bewältigung interkultureller Begegnungssituationen</p></td>
</tr>
<tr class="even">
<td colspan="2" class="table-block-header1">Methodische Kompetenzen</td>
</tr>
<tr class="odd">
<td colspan="2" class="table-block-content"><p>Textrezeption (Leseverstehen und Hörverstehen)<br>
Interaktion<br>
Textproduktion (Sprechen und Schreiben)<br>
Lernstrategien<br>
Präsentation und Mediennutzung<br>
Lernbewusstheit und Lernorganisation</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-standards-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Kompetenzbereiche entsprechend der Bildungsstandards für die erste Fremdsprache (Englisch/Französisch) für den Mittleren Schulabschluss (2003)
</figcaption>
</figure>
</div>
<p>Mit dieser Modellierung greifen die Bildungsstandards die Kompetenzbereiche des GER auf. Zu beachten ist, dass die methodischen Kompetenzen sowohl spezifisch für einzelne kommunikative Fertigkeiten als auch Fertigkeiten übergreifend sind. Lernbewusstheit und Lernorganisation können den personalen Kompetenzen zugeordnet werden. Auch die interkulturellen Kompetenzen realisie-ren sich in kommunikativen Fertigkeiten, in der Verfügung über spezifische sprachliche Mittel und in Strategien zur Interaktion. In schulischen und lebensweltlichen Kommunikationssituationen wirken i. d.&nbsp;R. ebenfalls mehrere Kompetenzen zusammen. Diesem integrativen Charakter sprachlicher Kompetenzen trägt im GER das Konstrukt der allgemeinen sprachlichen Kompetenz Rechnung. Allerdings ist sie als globales Konstrukt weder messbar noch gezielt förderbar, sodass es, trotz aller Überschneidungen und Unzulänglichkeiten der Modellierung, für beide Zwecke sinnvoll ist, die allgemeine sprachliche Kompetenz in einzelne Kompetenzbereiche und Teilkompetenzen zu unterteilen.</p>
<p>Die Verwendung des Begriffs „Kompetenz“ trägt dabei der Komplexität sprachlicher Anforderungen Rechnung, schließlich bezeichnet man mit Kompetenzen komplexe Dispositionen aus Wissen, Kön¬nen und Absichten. Auch fremdsprachliche Kompetenzen umfassen den Bereich des Wissens, ins¬besondere Wissen über sprachliche Mittel und ihre Verwendung sowie soziokulturelles Wissen und Wissen über das Funktionieren von Kommunikation. Kompetenzen beinhalten aber deutlich mehr als Wissen: Ganz wichtig ist das Verfügen über Methoden und Strategien zum Erwerb dieses Wis¬sens (z. B. Wie kann ich besonders gut neuen Wortschatz lernen?) sowie zur Anwendung dieses Wissens (z. B. Wie kann ich meine Meinung zu einem Thema so ausdrücken, sodass die anderen mich verstehen?). Für den schulischen Bereich, insbesondere für die Mittelstufe, erscheint uns die Bereitschaft, dieses sprachliche, methodische und strategische Wissen in die Praxis umzusetzen, ganz besonders wichtig (z. B. sich trotz aller sprachlichen Unzulänglichkeiten zu trauen, das Wort zu ergreifen oder einen kleinen Vortrag zu halten).</p>
<p>Kompetenzen sind also wesentlich weiter und komplexer gefasst als Fertigkeiten (skills, habiletés), bei denen allein die Tätigkeit im Mittelpunkt steht. Das Konzept der Fertigkeiten (im Sinne von skills, habiletés) ist zudem geprägt von der Vorstellung, dass einzelne Tätigkeiten isoliert betrachtet und trainiert werden können. Außerdem schwingt die Vorstellung mit, dass diese Tätigkeiten von Anfang an möglichst fehlerfrei erfolgen sollten. Kompetenzorientierung dagegen strebt an, die komplexen, aufeinander bezogenen Kompetenzen integriert zu entwickeln. Dies bedeutet, dass man im Unterricht zwar punktuell auf die gezielte Ent-wicklung einer Teilkompetenz (z. B. detailliertes Leseverstehen) fokussiert, dabei jedoch immer das entsprechende methodische, strategische und interkulturelle Können berücksichtigt. Bei dieser ge-zielten Entwicklung einer Einzelkompetenz im Rahmen einer Unterrichtsreihe sollte daher darauf geachtet werden, die anderen Kompetenzen analog zu ihrer Verwendung in lebensweltlichen Situa-tionen mit zu verwenden (z. B. detailliertes Leseverstehen, um sich mündlich oder schriftlich über die zentralen Argumente eines argumentativen Textes auszutauschen und sich eine eigene Mei-nung dazu zu bilden). Kompetenzorientierung berücksichtigt ebenfalls, dass die Korrektheit und Komplexität sprachlicher Äußerungen erst nach und nach steigt (vgl. die Angaben zu Fehlern und Hilfen in den einzelnen Niveaubeschreibungen).</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>